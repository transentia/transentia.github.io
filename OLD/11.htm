<!doctype html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"/>

    <title>Transentia - transentia pty. ltd.; development, consulting, training at the leading-edge of
        technology</title>


    <link rel="stylesheet" type="text/css" media="screen, print, handheld"
          href="wp-content/themes/transentia/css/site.css"/>


</head>

<body>

<div id="page">

    <div id="header">
        <p><a href="../index.htm"><img src="wp-content/uploads/widgets/transentia-logo-red-glow.gif" border="0"/></a></p>
        <p class="old-content">transentia's old content; click on the logo to return to the new content</p>
        <p id="blog-description">transentia pty. ltd.; development, consulting, training at the leading-edge of
            technology</p>
    </div><!-- #header -->

    <div id="content">
        <div class="pagination">
            <span class="next"><a href="DUMMY">Next &raquo;</a></span>
            <span class="previous"><a href="DUMMY">&laquo; Previous</a></span>
        </div>
        <div class="post hentry">
            <h1 class="entry-title">Batch Processing with Spring Batch</h1>
            <div class="entry-content">
                <p>I have blathered on about Spring Batch a few times in the past.</p>
                <p>The June 2009 edition of <a href="http://groovymag.com/">GroovyMag</a> carried my article on how to
                    use Spring Batch with Groovy; it&#8217;s republished (with permission) here. This was my second
                    article for GroovyMag, I have also <a
                            href="2010/01/25/solving-the-enterprise-integration-puzzle-with-spring-integration/">republished
                        the first one, on Spring Integration with Groovy</a>. </p>
                <p>As I lurk on the Groovy and Grails mailing lists, I see a real need &#8220;out there&#8221; for this
                    sort of infrastructure. Hopefully, this article will contribute to a small improvement in awareness.
                    Writing code should, after all, be the <a
                            href="http://www.azlyrics.com/lyrics/eagles/thelastresort.html">last resort</a> and not the
                    first&#8230;</p>
                <p>The source code is available, <a href="wp-content/uploads/2010/02/groovymag-spring-batch.zip">of
                    course</a>!</p>
                <hr/>
                <img src="wp-content/uploads/2009/06/gm8_400.jpg" alt=""/><br/>
                <p><strong>Batch Processing with Spring Batch<br/>
                    Dealing with Large Volumes of Data using Spring Batch and Groovy</strong></p>
                <hr/>
                <p><em>Even though a major focus of modern ideas such as Service Oriented Architectures and Software As
                    A Service is to facilitate and enhance live interactions between systems, batch processing remains
                    as important and widely-used as ever: practically every significant project contains a batch
                    processing component. Until the arrival of Spring Batch (version 1.0 was released in March, 2008),
                    no widely available, open source, reusable architecture framework for batch processing had existed;
                    batch processing had always been approached on an ad-hoc basis. This article will examine how Groovy
                    joins with Spring Batch to ease the pain of dealing with large data sets.</em></p>
                <h1>A Brief Overview of Spring Batch</h1>
                <p>Spring Batch (SB) is a relatively new member of the Spring family of technologies. There is no better
                    introduction than this excerpt from the documentation (see the &#8220;Learn More&#8221; section for
                    the URL):</p>
                <p style="padding-left: 30px;">Spring Batch is a lightweight, comprehensive batch framework designed to
                    enable the development of robust batch applications . . . Spring Batch builds upon the productivity,
                    POJO-based development approach, and general ease of use capabilities people have come to know from
                    the Spring Framework, while making it easy for developers to access and leverage more advance [sic]
                    enterprise services when necessary . . . Spring Batch provides reusable functions that are essential
                    in processing large volumes of records, including logging/tracing, transaction management, job
                    processing statistics, job restart, skip, and resource management. It also provides more advance
                    technical services and features that will enable extremely high-volume and high performance batch
                    jobs though optimization and partitioning techniques. Simple as well as complex, high-volume batch
                    jobs can leverage the framework in a highly scalable manner to process significant volumes of
                    information.</p>
                <p>SB provides a great deal of out-of-the-box functionality: very flexible adapters for reading from
                    flat files, facilities for dealing with JMS queues, JDBC-based database adapters (of course), along
                    with a simple workflow ability allowing conditional, repetitive and parallel processing.
                    Sophisticated error handling/recovery capabilities and simple job control round out the package.
                    Following the standard Spring Framework convention of &#8220;don&#8217;t reinvent the wheel,&#8221;
                    SB does not include a complete set of scheduling/job control tools, but works instead in conjunction
                    with existing Spring-friendly schedulers such as Quartz and Tivoli. Over time, SB will make more use
                    of other members of the Spring family and in particular Spring Integration, and this pairing in
                    particular should make for a formidable partnership.</p>
                <p>SB was seeded and driven by technology and developers from Accenture–as well as SpringSource and the
                    general Open Source community–and so claims to represent the distillation of a fair bit of
                    experience with &#8220;real world&#8221; needs and situations.</p>
                <h1>A Small Example Application</h1>
                <p>Because SB is rooted in the standard Spring Framework, it is quite compatible with Groovy (and is
                    also simple to integrate into Grails). As a demonstration, I&#8217;ll implement a simple batch
                    processing job, as follows: read and parse an input data file (where each record is formatted
                    according to a custom multiline format); validate each record (rejecting invalid records and writing
                    the relevant record to a dump file); apply a specific transformation to each remaining (valid)
                    record; and finally, write the valid, transformed data into an XML file.</p>
                <p>Figure 1 provides a simplified, high-level view of the application&#8217;s overall workflow.</p>
                <p><img src="wp-content/uploads/2010/02/figure_1.png" alt="figure_1" title="figure_1" width="828"
                        height="423" /><br/>
                    Figure 1: Simplified, high-level view of the workflow in the example application</p>
                <p>Figure 1 shows how an application initiates a SB job. The job is composed of a number of steps, which
                    are themselves composed of a number of substeps or tasklets. Tasklets are the building blocks of the
                    application and may read/write/validate/transform or otherwise ‘munge&#8217; the data.</p>
                <p>Even though this is a very simple batch-processing task, there are a number of tricky areas. Consider
                    the input data file format (an example is shown in Listing 1): this format contains data split into
                    logical sections (customer ID, contact information, credit card information, customer balance), with
                    one section to a line. Each line is a CSV-formatted record but some fields may themselves contain
                    fixed-width records. The whole record is &#8220;book-ended&#8221; by BEGIN/END markers, each of
                    which must have the same record number. The first two lines of the file are free-form
                    commentary.</p>
                <pre>
; this is a nasty file format
; it's going to be a challenge to process!
BEGIN0000000001
CUST,9876543210
CONT,0416123456,0712340987,fred@nowhere.com
CARD,visa:1234 1234 4321 4321:000
BAL,1000.00
END0000000001
</pre>
                <p>Listing 1: Example input data record</p>
                <p>Processing this data file is going to be quite a challenge and it is probably worth taking some time
                    to consider how you would tackle this task in plain Java or Groovy.</p>
                <p>It is safe to assume that the input data will contain numerous errors that makes validation and error
                    handling a priority consideration for this application. Validation is a common necessary chore that
                    is not difficult but is tedious and error-prone; by relying on standard Spring technologies, SB
                    helps simplify this task.</p>
                <p>Another minor challenge is concerned with producing the output XML document. Listing 2 shows how the
                    record given in should be written.</p>
                <pre>
&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;customers>
  &lt;customer sequence="0000000001">
    &lt;id>9876543210&lt;/id>
    &lt;mobile>0416123456&lt;/mobile>
    &lt;landline>0712340987&lt;/landline>
    &lt;email>fred@nowhere.com&lt;/email>
    &lt;provider>visa&lt;/provider>
    &lt;number>1234 1234 4321 4321&lt;/number>
    &lt;security>000&lt;/security>
    &lt;balance>1010.0&lt;/balance>
  &lt;/customer>
&lt;/customers>
</pre>
                <p>Listing 2: The resultant XML-formatted data record</p>
                <p>As is always the case with infrastructures and frameworks, one often gets the feeling of overkill
                    when working with a simple example such as the one in this article. Keep in mind however that as a
                    problem gets bigger, a framework becomes more and more necessary. Remember also that SB was written
                    with these large problem spaces in mind and so you may have difficulty seeing SB&#8217;s full
                    potential using this one simple example application.</p>
                <h2>The Driver Application</h2>
                <p>The example application uses a small command-line application to kick off the real batch job. SB
                    actually provides a simple command-line launcher to do this, but it is instructive to see how to
                    deal with a SB job by hand. As Listing 3 shows, the launcher is very simple and is a typically
                    simple Spring Framework-aware application.</p>
                <pre>
package au.com.transentia.sb

import o.s.batch.core.JobParametersBuilder
import o.s.context.support.ClassPathXmlApplicationContext

public class SpringBatch {

  public static void main(String[] args) {
    def context =
      new ClassPathXmlApplicationContext(['applicationContext.xml', 'job.xml'] as String[], true)

    def jobLauncher = context.getBean('jobLauncher')

    def job = context.getBean('job')

    def adjustmentPercent = 1.01D;

    def jobExecution =
      jobLauncher.run(job,
        new JobParametersBuilder().
          addDouble("adjustment.percent", adjustmentPercent).toJobParameters())
    jobExecution.with {
      println """
Job: $jobId
StartTime: $startTime; EndTime: $endTime
Duration: ${endTime.time - startTime.time} ms
Status=$exitStatus
"""
      stepExecutions.each { println "STEP: $it" }
    }
  }
}
</pre>
                <p>Listing 3: The Groovy driver application</p>
                <p>Note: throughout this article, the package name prefix ‘org.springframework&#8217; is abbreviated to
                    &#8216;o.s&#8217; to reduce line length and aid formatting and readability.</p>
                <p>Of interest here is the creation of the Spring application context. The application is looking for
                    two files on its classpath: applicationContext.xml defines the boilerplate SB infrastructure and
                    job.xml defines the SB job itself. This is a standard Spring development technique. I&#8217;ll look
                    at these files in more detail later.</p>
                <p>The job instance is created by the Spring application context and is looked up by the application
                    itself; this is the real meat of the batch definition, as we shall see.</p>
                <p>The jobLauncher instance obtained from the application context is part of SB. As the name suggests,
                    it is concerned with mediating access to a SB job instance. In this case, it will control execution
                    of the job instance defined in job.xml and retrieved by the application. The joblauncher.run()
                    method returns a SB jobExecution instance that allows the application to determine the state of the
                    associated job and its composite steps.</p>
                <p>JobParametersBuilder provides a way of defining a map of parameters that can be passed into a job and
                    subsequently accessed by the various steps and tasklets.</p>
                <p>Listing 4 shows (slightly edited) the application in action.</p>
                <pre>
Job: 0
StartTime: Fri May 01 16:25:50 EST 2009; EndTime: Fri May 01 16:25:54 EST 2009
Duration: 3117 ms
Status=exitCode=COMPLETED;exitDescription=
STEP: StepExecution: id=0, name=startupStep, status=COMPLETED,. . .
STEP: StepExecution: id=1, name=processStep, status=COMPLETED,. . .
STEP: StepExecution: id=2, name=endingStep, status=COMPLETED, exitStatus=COMP. . .
</pre>
                <p>Listing 4: Output from executing the application</p>
                <h2>Boilerplate Configuration</h2>
                <p>SB requires a certain amount of standard configuration to be put in place in preparation for job
                    execution. </p>
                <p>Listing 5 excerpts the relevant portion of the applicationContext.xml file that contains this
                    configuration.</p>
                <pre>
&lt;bean id="transactionManager"
      class="o.s.batch.support.transaction.ResourcelessTransactionManager"/>

&lt;bean id="jobRepository"
      class="o.s.batch.core.repository.support.MapJobRepositoryFactoryBean"
      p:transactionManager-ref="transactionManager"/>

&lt;bean id="jobLauncher"
      class="o.s.batch.core.launch.support.SimpleJobLauncher"
      p:jobRepository-ref="jobRepository" />
</pre>
                <p>Listing 5: Minimal-functionality SB configuration</p>
                <p>This is the least sophisticated SB configuration possible. This configuration establishes a no-op
                    transaction manager and a pure in-memory jobRepository. The latter configuration option means that
                    no distribution, persistence or job restart capabilities are available. For the purposes of this
                    application, this configuration is sufficient.</p>
                <p>In this example application, all processing is sequential and synchronous with the application;
                    however, it is possible to configure the jobLauncher instance to execute a job asynchronously to the
                    application. An asynchronous configuration would be appropriate if using SB in conjunction with a
                    Grails/AJAX application, which could initiate a job and then poll for status and update a visual
                    progress indicator until the job completes.</p>
                <h2>The Job Definition</h2>
                <p>The keystone of this application is actually the job.xml application context file. Because this is
                    quite long, I will go through it in sections.</p>
                <p>Note: The listings shown here have been edited and excerpted to save space (while hopefully remaining
                    clear). </p>
                <p>The full source code for this example is supplied with this edition of GroovyMag, of course.</p>
                <p>Listing 6 shows the place where it all begins: the job definition.</p>
                <pre>
&lt;batch:job id="job">
  &lt;batch:step id="startupStep" next="processStep">
    &lt;batch:tasklet ref="logStartupMessage"/>
  &lt;/batch:step>
  &lt;batch:step id="processStep" next="endingStep">
    &lt;batch:tasklet>
      &lt;batch:chunk skip-limit="100000"
                   reader="itemReader"
                   writer="itemWriter"
                   processor="compositeItemProcessor"
                   commit-interval="1">
        &lt;batch:streams>
          &lt;batch:stream ref="errorItemWriter"/>
        &lt;/batch:streams>
        &lt;batch:skippable-exception-classes>
          o.s.batch.item.file.FlatFileParseException
          o.s.batch.item.validator.ValidationException
        &lt;/batch:skippable-exception-classes>
      &lt;/batch:chunk>
      &lt;batch:listeners>
        &lt;batch:listener ref="skipListener"/>
      &lt;/batch:listeners>
    &lt;/batch:tasklet>
  &lt;/batch:step>
  &lt;batch:step id="endingStep">
    &lt;batch:tasklet ref="logEndingMessage"/>
  &lt;/batch:step>
&lt;/batch:job>
</pre>
                <p>Listing 6: The job definition</p>
                <p>This definition constructs a three-stage processing pipeline.While the first and last steps merely
                    print a status message, the middle step (with id=processStep) is the most important and what I focus
                    on here. The processStep step identifies the various input and output processors and also defines
                    the intermediate transformations/processes that will be executed on each record.</p>
                <p>An important SB concept introduced here is that of a chunk. A chunk defines the processing that is to
                    be done within a transaction boundary: a batch of records that may be written/rolled-back as a
                    whole, for instance. For this application, each record is treated as constituting a separate chunk
                    and so error handling, etc., is done on a per-record basis.</p>
                <p>The batch:streams, batch:listeners and batch:skippable-exception-classes configuration elements are
                    all related to the way that erroneous input records are handled. This will be looked at later.</p>
                <h3>Processing Step One: Input</h3>
                <p>Listing 7 defines the itemReader bean (and some of the necessary associated configuration), which
                    deals with reading and parsing the multiline record from the input data file.</p>
                <pre>
&lt;bean id="rawDataResource" class="o.s.core.io.FileSystemResource">
  &lt;constructor-arg value="resource/data/inputdata.dat"/>
&lt;/bean>

&lt;bean id="itemReader" class="au.com.transentia.sb.MultilineRecordReader">
  &lt;property name="flatFileItemReaderDelegate">
    &lt;bean class="o.s.batch.item.file.FlatFileItemReader"
          p:resource-ref="rawDataResource"
          p:linesToSkip="2">
      &lt;property name="lineMapper">
        &lt;bean class="o.s.batch.item.file.mapping.DefaultLineMapper"
            p:lineTokenizer-ref="multilineFileTokenizer">
          &lt;property name="fieldSetMapper">
            &lt;bean class="o.s.batch.item.file.mapping.PassThroughFieldSetMapper"/>
          &lt;/property>
        &lt;/bean>
      &lt;/property>
    &lt;/bean>
  &lt;/property>
&lt;/bean>

&lt;bean id="multilineFileTokenizer"
  class="o.s.batch.item.file.transform.PatternMatchingCompositeLineTokenizer">
  &lt;property name="tokenizers">
    &lt;map>
      &lt;entry key="BEGIN*" value-ref="beginLineTokenizer"/>
      &lt;entry key="CUST*" value-ref="customerLineTokenizer"/>
      &lt;entry key="CONT*" value-ref="contactLineTokenizer"/>
      &lt;entry key="CARD*" value-ref="cardLineTokenizer"/>
      &lt;entry key="BAL*" value-ref="balanceLineTokenizer"/>
      &lt;entry key="END*" value-ref="endLineTokenizer"/>
    &lt;/map>
  &lt;/property>
&lt;/bean>

&lt;bean id="csvLineTokenizer"
   class="o.s.batch.item.file.transform.DelimitedLineTokenizer"
   p:delimiter=","
   abstract="true"/>

&lt;bean id="fixedLineTokenizer"
      class="o.s.batch.item.file.transform.FixedLengthTokenizer"
      p:names="SKIP,sequence"
      abstract="true"/>

&lt;!--BEGIN0000000000-->
&lt;bean id="beginLineTokenizer"
      parent="fixedLineTokenizer"
      p:columns="1-5,6-"/>

&lt;!--END0000000000-->
&lt;bean id="endLineTokenizer"
      parent="fixedLineTokenizer"
      p:columns="1-3,4-"/>

&lt;!--CUST,9876543210-->
&lt;bean id="customerLineTokenizer"
      parent="csvLineTokenizer"
      p:names="SKIP,id"/>
</pre>
                <p>Listing 7: Input record handling</p>
                <p>Take your time to read through this code; the itemReader is quite a sophisticated piece of
                    infrastructure.<br/>
                    As you piece things together, you will see how almost everything is delegated to standard SB
                    classes: the actual reading of the file and skipping the comment lines is deferred to a
                    FlatFileItemReader, and the recognition and handling of the various logical sections in a record are
                    handled by the PatternMatchingCompositeLineTokenizer class (which itself defers to a number of line
                    tokenizers). In fact, the only custom activity here is the mapping of the parsed data to a simple
                    application-specific class via the au.com.transentia.sb.MultilineRecordReader class. A tremendous
                    amount of processing is being performed here with very little development effort.</p>
                <p>Note how the use of abstract parent definitions (e.g., fixedLineTokenizer), makes it possible to
                    write clearer configurations for several elements (e.g., beginLineTokenizer/endLineTokenizer). This
                    is a standard Spring technique that helps to keep the configuration file DRY (i.e., without
                    unnecessary repetition).</p>
                <p>Again, consider how much effort would be involved if you had to do all this by hand.</p>
                <p>Listing 8 and Listing 9 shows the MultilineRecord and MultilineRecordReader classes.</p>
                <pre>
package au.com.transentia.sb

public class MultilineRecord {
  String sequence
  String endSequence

  Long id

  String mobile
  String landline
  String email

  String provider
  String number
  String security

  BigDecimal balance

  @Override public String toString() { …elided… }
}
</pre>
                <p>Listing 8: The MultilineRecord class</p>
                <pre>
package au.com.transentia.sb

import …elided…

public class MultilineRecordReader implements
  ItemReader&lt;MultilineRecord>, ItemStream {
  private FlatFileItemReader&lt;FieldSet> flatFileItemReaderDelegate

  public MultilineRecord read() throws Exception
  {
    MultilineRecord mlr = null

    // flags to indicate the presence of component lines
    def customerSeen = false;
    def contactsSeen = false
    def ccSeen = false
    def balSeen = false

    def line
    while (line = this.flatFileItemReaderDelegate.read())
    {
      String prefix = line.readString(0);
      switch (prefix)
      {
        case 'BEGIN':
          mlr = new MultilineRecord(sequence: line.readString(1))
          break

        default:
          Assert.notNull(mlr, "MultilineRecord not yet intialised")
          switch (prefix)
          {
            case 'CUST':
              mlr.id = line.readLong(1)
              customerSeen = true
              break

            case 'CONT':
              mlr.with {
                mobile = line.readString(1)
                landline = line.readString(2)
                email = line.readString(3)
              }
              contactsSeen = true
              break

            case 'CARD':
              mlr.with {
                provider = line.readString(1)
                number = line.readString(2)
                security = line.readString(3)
              }
              ccSeen = true
              break

            case 'BAL':
              mlr.balance = line.readBigDecimal(1)
              balSeen = true
              break

            case 'END':
              // check all record fields seen
              Assert.isTrue(mlr &#038;&#038; customerSeen &#038;&#038;
                            contactsSeen &#038;&#038; ccSeen &#038;&#038; balSeen,
                  "Incomplete Record Found")
              mlr.endSequence = line.readString(1)
              return mlr
              break
          }
      }
    }
    null
  }

  … elided …
}
</pre>
                <p>Listing 9: The MultilineRecordReader class</p>
                <p>The MultilineRecordReader class is responsible for allocating the various fields of each tokenized
                    line (offered as SB FieldSets) to a single new instance of a MultilineRecord. It also performs some
                    minor validation to ensure that there are no missing logical sections. Note how Groovy&#8217;s
                    versatile switch statement and the use of Groovy&#8217;s enhanced Object with method makes the
                    processing much clearer than it would be in plain Java.</p>
                <h3>Processing Step Two: Output</h3>
                <p>As every first-year CompSci student learns, after input comes processing, followed by output.
                    Naturally, I am not going to follow this sequence! In an attempt to achieve a less convoluted
                    narrative, I&#8217;ll now look at output processing (the third stage of the processStep step).
                    Listing 10 shows the requisite configuration for the itemWriter.</p>
                <pre>
&lt;bean id="itemWriter"
      class="o.s.batch.item.xml.StaxEventItemWriter"
      p:resource-ref="processedOutputResource"
      p:marshaller-ref="multiLineRecordMarshaller" p:rootTagName="customers"
      p:overwriteOutput="true"/>

&lt;bean id="multiLineRecordMarshaller" class="o.s.oxm.xstream.XStreamMarshaller">
  &lt;property name="useAttributeFor">
    &lt;map>
      &lt;entry key="sequence">
        &lt;value type="java.lang.Class">java.lang.String&lt;/value>
      &lt;/entry>
    &lt;/map>
  &lt;/property>
  &lt;property name="omittedFields">
    &lt;map>
      &lt;entry key="au.com.transentia.sb.MultilineRecord" value="endSequence"/>
    &lt;/map>
  &lt;/property>
  &lt;property name="aliases">
    &lt;map>
      &lt;entry key="customer"
             value="au.com.transentia.sb.MultilineRecord"/>
    &lt;/map>
  &lt;/property>
&lt;/bean>

&lt;bean id="processedOutputResource" class="o.s.core.io.FileSystemResource">
  &lt;constructor-arg value="resource/data/job-output.xml"/>
&lt;/bean>
</pre>
                <p>Listing 10: Output XML processing</p>
                <p>The itemWriter configuration is quite straightforward. Output handling is actually delegated to a
                    marshaller instance. In this case, the Spring OXM project is brought to bear to simplify XML
                    generation. The XStreamMarshaller is only very minimally configurable (but quite performant…the
                    age-old tradeoff): it is possible to render the sequence field as an XML attribute and not to render
                    the endSequence field at all, but that is pretty much all the configuration possible.</p>
                <h3>Processing Step Three: Validation and Transformation</h3>
                <p>Now that we&#8217;ve seen the mechanics of writing a file, it is time to move on to (or more
                    accurately: back to) the middle processing step.</p>
                <p>Listing 11 shows the configuration of the processing tasks.</p>
                <pre>
&lt;bean id="compositeItemProcessor"
      class="o.s.batch.item.support.CompositeItemProcessor">
  &lt;property name="itemProcessors">
    &lt;list>
      &lt;ref local="validatingItemProcessor"/>
      &lt;ref local="embiggenProcessor"/>
    &lt;/list>
  &lt;/property>
&lt;/bean>

&lt;bean id="validatingItemProcessor"
      class="o.s.batch.item.validator.ValidatingItemProcessor">
  &lt;constructor-arg ref="validator"/>
&lt;/bean>

&lt;bean id="validator"
      class="o.s.batch.item.validator.SpringValidator">
  &lt;property name="validator">
    &lt;bean id="luhnValidator"
          class="o.s.validation.valang.ValangValidator">
      &lt;property name="customFunctions">
        &lt;map>
          &lt;entry key="luhn" value="au.com.transentia.sb.LuhnFunction"/>
        &lt;/map>
      &lt;/property>
      &lt;property name="valang">
        &lt;value>
          &lt;![CDATA[
{ id : ? > 0 :
  'id field must be a natural number' }
{ endSequence : ? is not blank :
  'end sequence number field missing' }
{ sequence : ? is not blank :
  'begin sequence number field missing' }
{ endSequence : endSequence == sequence :
  'mismatched begin/end sequence numbers' }
{ mobile : match('\\d{10}',?) == true :
  'mobile field must be 10 digits' }
{ landline : match('\\d{8,10}',?) == true :
  'landline field must be 8-10 digits' }
{ provider : ? in 'amex', 'visa', 'macd' :
  'card provider field should be one of "visa", "amex" or "macd"' }
{ number : match('\\d{4}[ ]\\d{4}[ ]\\d{4}[ ]\\d{4}',?) == true :
  'card number field must match the format "xxxx xxxx xxxx xxxx"' }
{ number : luhn(?) == true :
  'card number luhn check failed' }
{ security : match('\\d{3}',?) == true :
  'card number field must be 3 digits' }
{ email : ? is not blank :
  'email field missing' }
{ email : email(?) == true :
  'email field is not a valid email address' }
{ balance : ? is not blank :
  'balance field missing' }
]]&gt;
        &lt;/value>
      &lt;/property>
    &lt;/bean>
  &lt;/property>
&lt;/bean>

&lt;bean id="errorOutputResource"
      class="o.s.core.io.FileSystemResource">
  &lt;constructor-arg value="resource/data/errors.txt"/>
&lt;/bean>

&lt;bean id="passthroughLineAggregator"
      class="au.com.transentia.sb.PassThroughLineAggregator"/>

&lt;bean id="errorItemWriter"
      class="o.s.batch.item.file.FlatFileItemWriter"
      p:resource-ref="errorOutputResource"
      p:lineAggregator-ref="passthroughLineAggregator"
      p:shouldDeleteIfExists="true"/>

&lt;bean id="skipListener" class="au.com.transentia.sb.SkipListener"
      p:writer-ref="errorItemWriter"/>

&lt;bean id="embiggenProcessor"
      class="au.com.transentia.sb.EmbiggenProcessor"
      scope="step"
      p:percent="#{jobParameters[adjustment.percent]}"/>
</pre>
                <p>Listing 11: Configuration of processing tasks</p>
                <p>For this application, the middle processing part of the pipeline is itself a two-stage composite
                    process: first comes validation (and possibly rejection of invalid data), followed by
                    transformation. This is configured through the compositeItemProcessor bean (which is referenced by
                    the processStep step in ).<br/>
                    SB allows the use of any of the available Spring-compatible validation systems. For this example I
                    have chosen to use the Valang Spring module, because of its clear declarative nature.</p>
                <p>The validator bean contains a plaintext valang property which defines a series of expressions that
                    should be evaluated against the various properties of the bean to which it is applied. For
                    example:</p>
                <pre>
{ id : ? &gt; 0 : 'id field must be a natural number' }
</pre>
                <p>If the given expression evaluates to false, validation fails and the associated message is added to
                    the list of errors being maintained by the validator bean.</p>
                <p>While Valang provides a series of standard functions (such as email, which checks to ensure that a
                    field contains a valid email address), it cannot account for all possible requirements. It can be
                    augmented via the customFunctions property, however, and it is this ability that allows me to define
                    an application-specific function. To illustrate this, I&#8217;ll introduce a check for the validity
                    of the credit card number field (using the so-called Luhn function; see &#8220;Learn More&#8221; for
                    a reference to how this works), as is shown in Listing 12.</p>
                <pre>
package au.com.transentia.sb

import …elided…

public class LuhnFunction extends AbstractFunction {

  public LuhnFunction(Function[] arg0, int arg1, int arg2) {
    super(arg0, arg1, arg2);
    definedExactNumberOfArguments(1);
  }

  @Override
  protected Object doGetResult(Object target) throws Exception {
    def str = getArguments()[0].getResult(target).toString()
    isValid(str)
  }

  public static boolean isValid(String cardNumber) {
    def sum = 0
    def addend = 0
    def timesTwo = false

    cardNumber.replaceAll(' ', '').each {dc ->
      def digit = Integer.valueOf(dc)
      if (timesTwo)
      {
        addend = digit * 2
        if (addend > 9)
          addend -= 9;
      }
      else
        addend = digit
      sum += addend
      timesTwo = !timesTwo
    }

    (sum % 10) == 0
  }
}
</pre>
                <p>Listing 12: Luhn function class</p>
                <p>This allows the use of the luhn() function as if it were a built-in Valang function:</p>
                <pre>
{ number : luhn(?) == true : 'card number luhn check failed' }
</pre>
                <p>Valang is a powerful and effective validation framework. Its most important feature is probably that
                    since it uses &#8220;near natural language&#8221; configuration, an application&#8217;s validation
                    rules can be reviewed and changed by any appropriate product owner or business representative and
                    this can make for a higher quality product. Valang is a standalone framework and well worth further
                    study (see the &#8220;Learn More&#8221; section for the URL).</p>
                <p>Refer back to Listing 6. You will see that in the event of a ValidationException, processing of a
                    chunk is skipped. This application registers a listener for this situation that simply writes the
                    offending record to a configured itemWriter. Listing 13 shows the appropriate class.</p>
                <pre>
package au.com.transentia.sb

import org.springframework.batch.core.listener.SkipListenerSupport

public class SkipListener extends SkipListenerSupport&lt;MultilineRecord, Object> {

  def writer

  @Override
  public void onSkipInProcess(MultilineRecord item, Throwable t) {
    writer.write ( [ item ] )
  }
}
</pre>
                <p>Listing 13: Error handling skip listener class</p>
                <p>The configured itemWriter has an associated line aggregator that performs preprocessing before the
                    actual write takes place. In this case, the PassThroughLineAggregator class simply performs a
                    toString operation on the presented item, as Listing 14 shows.</p>
                <pre>
package au.com.transentia.sb

import org.springframework.batch.item.file.transform.LineAggregator

public class PassThroughLineAggregator implements LineAggregator&lt;MultilineRecord> {
  public String aggregate(MultilineRecord item) {
    item.toString()
  }
}
</pre>
                <p>Listing 14: PassThroughLineAggregator class</p>
                <p>The second part of the composite processing step shown in deals with transforming the now-valid data
                    record. This particular transformation represents a business rule: as each record is transformed,
                    its balance should be adjusted by a certain percentage. This requires a small piece of Groovy, the
                    EmbiggenProcessor. Listing 15 shows this simple class in its entirety.</p>
                <pre>
package au.com.transentia.sb

import org.springframework.batch.item.ItemProcessor

public class EmbiggenProcessor
  implements ItemProcessor&lt;MultilineRecord, MultilineRecord> {

  def percent

  public MultilineRecord process(MultilineRecord mlr) throws Exception {
    mlr.balance *= percent

    mlr
  }
}
</pre>
                <p>Listing 15: The EmbiggenProcessor class</p>
                <p>If you refer back to Listing 3 and Listing 11, you will see how the percent value is injected into
                    the EmbiggenProcessor class from the application via the job.xml file.</p>
                <h2>Performance</h2>
                <p>To paraphrase Benjamin Disraeli, first Earl of Beaconsfield: &#8220;there are lies, damn lies and
                    performance measurements.&#8221; Since many batch jobs deal with very large data sets, the
                    performance of SB is bound to be of paramount interest to some. I am a coward! I am going to merely
                    dip my toe into this potentially turbulent topic and just let you know that <em>on my laptop</em>,
                    the complete processing of 42,500 records took 92,381 ms. That makes about 2.17 ms per record. Not
                    too shabby in my opinion–but of course, your mileage may vary.</p>
                <h1>Wrapping Up</h1>
                <p>You&#8217;ve now walked through a complete SB application. A large proportion of the application is
                    declarative configuration. I like this style of working: it reduces the amount of ‘real&#8217;
                    coding that is required and thus minimizes the opportunity for error. For those parts of the problem
                    space that are not directly covered by the standard components, Groovy has proved to be a very
                    effective tool; with minimal effort and coding, Groovy has allowed me to very effectively
                    concentrate on creating a clear solution, which also minimizes the opportunity to introduce
                    bugs.</p>
                <p>I continue to find it impressive that Groovy—a dynamic language—can still effectively work with
                    highly-typed interfaces such as those exposed by SB: checked exceptions, strongly typed parameter
                    lists, and even generic classes can be handled with ease. At the same time, Groovy can let me work
                    with frameworks such as Valang without forcing me to deal with ‘nasties&#8217; such as adapter
                    classes, proxies, out-of-process adapters, etc. This means that an inveterate Java programmer like
                    myself can continue to apply his existing skillset—with its hard-won collection of lessons learned,
                    tricks and tips picked up over time—while also taking advantage of the productivity and ease of use
                    of Groovy&#8217;s modern dynamic language. In my not-so-humble opinion, this is important and will
                    surely contribute to a rapid increase in Groovy&#8217;s popularity.</p>
                <h1>Learn More</h1>
                <dl>
                    <dt>Spring Batch</dt>
                    <dd><a href="http://static.springsource.org/spring-batch/">http://static.springsource.org/spring-batch/</a>
                    </dd>
                    <dt>Spring Valang module</dt>
                    <dd><a href="https://springmodules.dev.java.net/">https://springmodules.dev.java.net/</a></dd>
                    <dt>Spring OXM</dt>
                    <dd><a href="http://static.springframework.org/spring-ws/sites/1.5/reference/html/oxm.html">https://springmodules.dev.java.net/</a>
                    </dd>
                    <dt>The Luhn Function</dt>
                    <dd><a href="http://www.merriampark.com/anatomycc.htm">http://www.merriampark.com/anatomycc.htm</a>
                    </dd>
                </dl>

            </div><!--/entry-content-->


            <p class="filed tags">Tags: Groovy, GroovyMag, Programming, Tools</p>    <!--/filed-->

        </div><!-- .post -->
        <div class="post hentry">
            <h1 class="entry-title">MarkupBuilder, How Do I love Thee&#8230;</h1>
            <div class="entry-content">
                <p>In oh, so many ways!</p>
                <p>Groovy&#8217;s <a
                        href="http://docs.groovy-lang.org/latest/html/api/groovy/xml/MarkupBuilder.html">MarkupBuilder</a> class can
                    really clean up your code.</p>
                <pre>
import groovy.xml.*

def out = new StringWriter()
def b = new MarkupBuilder(out)
b.table(id: 'test', border: 0) {
  tbody {
    tr {
      td "hello"
      td(id: 'hello_id', 'hello')
      td(id: 'test', /hello/)
      td(id: 'esc') { mkp.yield '&amp;nbsp;' }
      td(id: 'unesc') { mkp.yieldUnescaped '&amp;nbsp;' }
      td(id: 999) { mkp.yield 999 }
      td(id: 99) { mkp.yieldUnescaped 99 }
      td(id: 88) { mkp.yieldUnescaped 'hello' }
      td(id: 77) { mkp.yieldUnescaped "hello2" }
      td(id: 66) { mkp.yieldUnescaped """hello3""" }
      // gives compilation error "unexpected token: } at line: 19, column: 48":
      //   td(id: 55) { mkp.yieldUnescaped /hello4/ }
      td(id: 55) { mkp.yieldUnescaped "" + /hello4/ }
    }
  }
}

println out.toString()
</pre>
                <p>This produces:</p>
                <pre>
&lt;table id='test' border='0'>
  &lt;tbody>
    &lt;tr>
      &lt;td>hello&lt;/td>
      &lt;td id='hello_id'>hello&lt;/td>
      &lt;td id='test'>hello&lt;/td>
      &lt;td id='esc'>&amp;nbsp;&lt;/td>
      &lt;td id='unesc'>&nbsp;&lt;/td>
      &lt;td id='999'>999&lt;/td>
      &lt;td id='99'>99&lt;/td>
      &lt;td id='88'>hello&lt;/td>
      &lt;td id='77'>hello2&lt;/td>
      &lt;td id='66'>hello3&lt;/td>
      &lt;td id='55'>hello4&lt;/td>
    &lt;/tr>
  &lt;/tbody>
&lt;/table>
</pre>
                <p>This was just another of those &#8220;external brain dump&#8221; posts&#8230;I didn&#8217;t want to
                    loose my memory and there are a few subtle points (or at least a few things that I found out by
                    trial-and-error). There&#8217;s not too much <a
                            href="http://docs.groovy-lang.org/latest/html/Creating+XML+using+Groovy's+MarkupBuilder">other</a> stuff
                    around.</p>

            </div><!--/entry-content-->


            <p class="filed tags">Tags: Groovy, Programming</p>    <!--/filed-->

        </div><!-- .post -->
        <div class="post hentry">
            <h1 class="entry-title">Solving the Enterprise Integration Puzzle with Spring Integration</h1>
            <div class="entry-content">
                <p>Back in May 2009, I GroovyMag.</p>
                <p>GroovyMag is very nice in that it allows the author to republish their work after a &#8216;decent&#8217;
                    interval has passed (either 60 or 90 days, can&#8217;t quite remember at the moment). That period is
                    well and truly passed for this article so here it is in its full resplendency. Enjoy!</p>
                <p><em>[edit]</em><br/>
                    Forgot to <a href="wp-content/uploads/2010/01/exemplar-2009.apr.15.zip">make the source
                        available</a> when I first republished this article. Silly me. All fixed now!</p>
                <hr/>
                <img src="wp-content/uploads/2009/05/gm7_400.jpg" alt="gm7_400" title="gm7_400" width="400"
                     height="517" /><br/>
                <p><strong>Solving the Enterprise Integration Puzzle<br/>
                    Getting Started with Spring Integration</strong></p>
                <hr/>
                <p>Groovy is frequently promoted as &#8220;the scripting language for the JVM.&#8221; Grails is often
                    described as being &#8220;great for smaller, quick-to-build web applications.&#8221; Neither of
                    these pieces of perceived wisdom really gives the Groovy/Grails combination its due: a powerful tool
                    in the Systems Integrator&#8217;s armory. This article will show how Groovy and Grails&#8211;in
                    conjunction with SpringSource&#8217;s up-and-coming &#8220;Spring Integration&#8221; project&#8211;can
                    make complex systems integration tasks as easy as building a standalone web application.</p>
                <h1>A Brief Overview of Spring Integration</h1>
                <p>Systems integration is frequently likened to attempting to piece together a badly made jigsaw puzzle.
                    The end goal is often quite fuzzy; there may be several potential solutions to consider; there may
                    be many conflicting approaches to evaluate; and when all is said and done, sometimes all that can be
                    done is to say &#8220;To heck with the Grand Plan!&#8221; and &#8216;adapt&#8217; the puzzle using a
                    pair of nice sharp scissors.</p>
                <p>Spring Integration (SI) is a recent project within the Spring stable that provides numerous tools to
                    make the systems integration task less frustrating. SI builds on several existing Spring
                    stablemates, but provides a unified way of configuring these components and linking them together.
                    According to SI, all message endpoints (which act with and on behalf of application components)
                    interact via messages sent over various flavors of messaging channels, perhaps undergoing various
                    transformations along the way. In addition, external resources (files, JMS-based queueing systems,
                    SOAP-based WebServices, etc.)  interact with these channels via simple-to-configure adapters.</p>
                <p>SI imposes very little onto the developer; almost everything in the system can be implemented using
                    simple POG/JOs (Plain Old Groovy/Java Objects) and configuration is typically via XML or
                    Annotations.</p>
                <p>SI provides out-of-the-box support for many of the patterns defined in Hohpe and Woolfe&#8217;s <em>Enterprise
                    Integration Patterns</em> book and associated website and&#8211;as this article will show&#8211;is
                    quite &#8220;Groovy friendly.&#8221;</p>
                <h1>A Small Example Application</h1>
                <p>In this article, I am going to take a very simple systems integration task and build a small example
                    application. The application is a small Grails application that performs a simple function: given a
                    customer number, it calculates the shipping cost for a single widget.</p>
                <p>To show how Spring Integration can be used, I am assuming that a customer will enter their customer
                    ID into a Grails-originated web page, which is then routed to one instance of a set of JMS servers.
                    The associated address data is then retrieved, the city field extracted and then passed on to a
                    SOAP-based WebService that calculates the cost of shipping widgets from Brisbane to the customer&#8217;s
                    home city. To add a smidgen of realism, I have built the various services to be completely
                    unrelated; in particular, they do not reference any form of standardized messaging schema. The
                    integration pipeline needs to handle various simple message types, including strings, CSV-formatted
                    data records, XML-formatted strings and floats.</p>
                <p>Figure 1 provides a high-level view of the application.</p>
                <p><img src="wp-content/uploads/2010/01/gm_si_image001.jpg" alt="gm_si_image001"
                        title="gm_si_image001" width="665" height="289" /></p>
                <p>Figure 1: The processing flow and major components comprising the example application</p>
                <p>The various steps highlighted in this flow are:</p>
                <ol>
                    <li>The customer ID (a simple string) is entered into the Grails web application and passed off to a
                        generic SI gateway. The gateway places the customer ID on an internal channel that leads to a
                        message router.
                    </li>
                    <li>The router retrieves the message from its inbound channel and determines which available channel
                        to use to ensure that the message is handled by the appropriate JMS server instance.
                    </li>
                    <li>The message is then handled by a SI JMS &#8220;channel adapter,&#8221; which deals with the
                        mechanics of working with the underlying external JMS server.
                    </li>
                    <li>The nominated JMS server instance produces a record (a CSV-formatted string) that is placed onto
                        a shared reply channel.
                    </li>
                    <li>The CSV record is removed from the shared channel and transformed. The result of the
                        transformation is an XML-formatted string which is again placed on a ‘downstream&#8217; queue.
                    </li>
                    <li>The WebService channel adaptor removes the string from its request channel and invokes the
                        external SOAP WebService for further processing.
                    </li>
                    <li>The WebService response (a single float) is then passed back to the originating messaging
                        gateway, which returns it to the Grails controller.
                    </li>
                </ol>
                <p>This is a very simple system and it may seem that this is overkill. There is a payoff, however: SI
                    makes it easy to plug in disparate (often legacy) systems and thus produces an expandable framework
                    that is capable of being built out to cover future, more complex, situations.</p>
                <h2>The Pieces of the Jigsaw Puzzle</h2>
                <p>Before starting out on the integration exercise proper, it is worth taking a quick look at the
                    various pieces of the jigsaw puzzle that are going to be joined together.</p>
                <p>You will quickly see that all the pieces are exceptionally simplistic. I haven&#8217;t even tried to
                    make them correspond to a multitude of real-life issues such as error handling, logging,
                    configuration, etc., which have been almost completely ignored. This is by design: for the purposes
                    of this article, I want to focus mostly on SI, not on the various services.</p>
                <h2>The Grails Web Application</h2>
                <p>Figure 2 shows the Grails web interface &#8220;in action.&#8221; It is very simple, with only a
                    single form and a single results page.</p>
                <p><img src="wp-content/uploads/2010/01/gm_si_image002.jpg" alt="gm_si_image002"
                        title="gm_si_image002" width="665" height="246" /></p>
                <p>Figure 2: The deployed Grails web application</p>
                <p>The ‘meat&#8217; of the application (as far as this article is concerned) lies in the single Grails
                    controller class shown in Listing 1.</p>
                <pre>
public class SpringIntegrationController {

  def siGateway

  def index = { }

  def submit = {
    long start = System.currentTimeMillis()
    def msg = params.custid
    siGateway.send(msg)
    def got = siGateway.receive()
    flash.message =
      "Query took: ${System.currentTimeMillis() - start} millis."
    [shippingCost: got]
    }
  }
</pre>
                <p>Listing 1: The Grails controller class</p>
                <p>There are two points of interest in this simple class.</p>
                <p>The siGateway instance injected from the Spring application context constitutes the sole point of
                    contact between the Grails web application and the SI framework. (In theory, SI allows for an even
                    less intrusive interface than this, based around dynamically constructed proxies, but a bug surfaced
                    as I started writing the application…no matter, the hard way is not too onerous to use and I am sure
                    that the SI guys will soon squash the bug.)</p>
                <p>The submit closure is responsible for handling the POSTed form data and for driving the injected
                    siGateway instance through its paces. It is pretty straightforward: all the action is happening over
                    in &#8220;SI-land.&#8221;</p>
                <h2>The JMS Application</h2>
                <p>For the example application, I have written a very simple JMS service (using Apache ActiveMQ as the
                    messaging provider), as shown in Listing 2.</p>
                <pre>
import javax.jms.Session
import org.apache.activemq.ActiveMQConnectionFactory

public class AMQService
{
  private static factory =
	  new ActiveMQConnectionFactory("tcp://localhost:61616")

  public static void main(String[] args) throws Exception
  {
    def cKey = args[0]
    def cFile = args[1]

    println 'Starting...'
    println "Config key: $cKey"
    println "Config file: $cFile"

    def config =
      new ConfigSlurper(cKey).parse(new File(cFile).toURL())

    def database = config.database
    println "Database: $database"

    def inQ = config.inQ
    println "Incoming Queue: $inQ"

    def replyTopic = config.replyTopic
    println "Reply Topic: $replyTopic"

    def qConn = factory.createQueueConnection()
    def qSession =
      qConn.createQueueSession(false, Session.AUTO_ACKNOWLEDGE)
    def consumer =
      qSession.createConsumer(qSession.createQueue(inQ))

    def tConn = factory.createTopicConnection()
    def tSession =
      qConn.createTopicSession(false, Session.AUTO_ACKNOWLEDGE)
    def producer =
      tSession.createProducer(tSession.createTopic(replyTopic))

    qConn.start()
    tConn.start()

    for ( ; ; )
      process(database,
              tSession.createTextMessage(),
              consumer,
              producer)
  }

  private static process(database, replyMessage, consumer, producer)
  {
    try
    {
      def textMessage = consumer.receive()  // indefinite blocking
      replyMessage.with {
        setText(getResponse(database, textMessage.getText()))
        setJMSCorrelationID(textMessage.getJMSCorrelationID())
      }
      producer.send(replyMessage)
    }
    catch (Throwable t)
    {
      t.printStackTrace()
    }
  }

  private static getResponse(database, inMsg)
  {
    def resp = database[inMsg]
    println "Request: '$inMsg'; Response: '$resp'"
    resp
  }
}
</pre>
                <p>Listing 2: The JMS server</p>
                <p>This is a standard JMS service; no need to elaborate.</p>
                <p>One point to note (that is not directly SI-related, but of interest nonetheless) is that the service
                    is written to allow multiple instances to run at the same time, dealing with a partitioned data
                    space. For the purposes of the example application, I have configured two instances. One instance is
                    prepared to deal with customer IDs whose first character is in the range a-l and the second will
                    deal with the rest of the alphabet.</p>
                <p>The service accepts input via a uniquely-designated input queue, but sends its response to a shared
                    topic. This structure simplifies things by ensuring that any downstream component merely has to
                    handle a single publish/subscribe channel (which can carry data from multiple sources), rather than
                    trying to deal with a multitude of point-to-point links.</p>
                <p>Each server instance is driven by a pair of application parameters, defining:</p>
                <ul>
                    <li>The location of the configuration file to use</li>
                    <li>The appropriate environment section in the designated configuration file</li>
                </ul>
                <p>The configuration file supplies:</p>
                <ul>
                    <li>The name of the input queue to use</li>
                    <li>The name of the output topic to receive the responses</li>
                    <li>The actual static database to use (I did warn that these applications were extremely simple!)
                    </li>
                </ul>
                <p>The service makes use of ConfigSlurper&#8217;s ability to deal with different environment sections
                    and so I can define a single configuration file (see Listing 3) to configure the different instances
                    uniquely.</p>
                <pre>
replyTopic="SI.REPLY.TOPIC"

replyTopic="SI.REPLY.TOPIC"

environments {
  al {
    inQ="SI.AL.REQUEST"
    database=['b9876':'123 Nowhere St,Brisbane',
              'f0234':'42 Imaginary Place,Darwin']
    }
  mz {
    inQ="SI.MZ.REQUEST"
    database=['x5555':'123 Fake St,Hobart',
              'w8888':'000 Talkfest Lane,Canberra']
    }
  }
</pre>
                <p>Listing 3: JMS server configuration file</p>
                <p>This service accepts a string, but returns a CSV-formatted record.</p>
                <h2>The WebService</h2>
                <p>The final part in the jigsaw puzzle is a SOAP WebService built on top of the facilities provided by
                    GroovyWS.</p>
                <p>The service&#8217;s raison-d&#8217;être is to retrieve the cost of shipping <em>n</em> widgets
                    between major cities in Australia; see Listing 4 and Listing 5.</p>
                <pre>
public class ShippingCostWebService {

  static costs = [
    Brisbane: [ Brisbane:0.0F,
                Darwin:44.44F,
                Canberra:22.22F,
                Hobart:88.88F ],
    Darwin: [ Brisbane:44.44F,
              Darwin:0.0F,
              Canberra: 33.33F,
              Hobart: 99.99F ],
    Canberra: [ Brisbane:22.22F,
                Darwin:33.33F,
                Canberra: 0.0F,
                Hobart: 77.77F ],
    Hobart: [ Brisbane:88.88F,
              Darwin:99.99F,
              Canberra: 77.77F,
              Hobart: 0.0F ],
  ]

  Float calculateShippingCost(String fromLoc,
                              String toLoc,
                              Integer nItem) {
    def cost = costs[fromLoc][toLoc] * nItem
    println "calculateShippingCost($fromLoc,$toLoc,$nItem) => $cost"
    cost
    }
}
</pre>
                <p>Listing 4: The shipping cost WebService</p>
                <pre>
println 'Starting...'

def ws = new groovyx.net.ws.WSServer()

ws.setNode("ShippingCostWebService",
           "http://localhost:6980/ShippingCostWebService")

ws.start()

println '...Started.'
</pre>
                <p>Listing 5: The GroovyWS WebService server harness</p>
                <p>I can&#8217;t lie! This is just an old WebService that I had lying around that I created for a
                    conference presentation, and which I have adopted for this application. It doesn&#8217;t have a
                    customized API and isn&#8217;t necessarily a perfect fit to the task. In the systems integration
                    world, improvisation is often required to squeeze data out of the numerous ‘sub-optimal&#8217; nooks
                    and crannies that are found all over an enterprise.</p>
                <h1>Joining the Pieces Together</h1>
                <p>Now that you are familiar with the basic componentry, it is time to look at SI proper.</p>
                <p>As with any Spring project, SI is configured separately to the actual code in an application. Since
                    this application is based on Grails, I have chosen to use the nice resources.groovy Grails Spring
                    Beans DSL configuration file, rather than the ‘traditional&#8217; XML-based configuration.</p>
                <p>Listing 6 shows the complete configuration.</p>
                <pre>
beans = {
  xmlns si:"http://www.springframework.org/schema/integration"
  xmlns jms:"http://www.springframework.org/schema/integration/jms"
  xmlns stream:"http://www.springframework.org/schema/integration/stream"
  xmlns ws:"http://www.springframework.org/schema/integration/ws"

  // SI componentry and plumbing
  si {
    poller(default: true) {
      "interval-trigger"(interval: 1, "time-unit": "SECONDS")
    }
    router("input-channel": "routerChannel",
           ref: "highLowRouter",
           method: "route")
    transformer("input-channel": "InboundTopic",
                "output-channel": "TransformedInbound",
                ref: "csvStringTransformer",
                method: "transform")
    channel(id: "routerChannel")
    channel(id: "ALOutboundChannel")
    channel(id: "MZOutboundChannel")
    channel(id: "RoutingRejectChannel") {
      queue(capacity: "256")
    }
    channel(id: "TransformedInbound") {
      queue(capacity: "16")
    }
    channel(id: "InboundTopic") {
      queue(capacity: "16")
    }
    channel(id: "ShippingCostChannel",
            dataType: "java.lang.Float") {
      queue(capacity: "16")
    }
  }

  stream {
    "stderr-channel-adapter"(channel:"errorChannel",
                             "append-newline": true)
  }

  // WebService stuff
  ws {
    "outbound-gateway"("request-channel": "TransformedInbound",
                       "reply-channel": "ShippingCostChannel",
                        uri: "http://localhost:6980/ShippingCostWebService")
  }

  // AMQ/JMS stuff
  connectionFactory(org.apache.activemq.pool.PooledConnectionFactory) { bean ->
    bean.destroyMethod = "stop"
    connectionFactory = { org.apache.activemq.ActiveMQConnectionFactory cf ->
      brokerURL = "tcp://localhost:61616"
    }
  }

  "AL.REQUEST"(org.apache.activemq.command.ActiveMQQueue, "SI.AL.REQUEST")
  "MZ.REQUEST"(org.apache.activemq.command.ActiveMQQueue, "SI.MZ.REQUEST")
  "REPLY"(org.apache.activemq.command.ActiveMQTopic, "SI.REPLY.TOPIC")

  jms {
    "outbound-channel-adapter"(channel: "ALOutboundChannel",
                               destination: "AL.REQUEST")

    "outbound-channel-adapter"(channel: "MZOutboundChannel",
                               destination: "MZ.REQUEST")

    "message-driven-channel-adapter"(channel: "InboundTopic",
                                     destination: "REPLY")
   }

  // general componentry
  siGateway(org.springframework.integration.gateway.SimpleMessagingGateway) {
    requestChannel = ref("routerChannel")
    replyChannel = ref("ShippingCostChannel")
    replyTimeout = "10000"
  }

  highLowRouter(au.com.transentia.si.LookupRouter)

  csvStringTransformer(au.com.transentia.si.CsvTransformer) {
    homeBase = 'Brisbane'
  }
}
</pre>
                <p>Listing 6: The Spring Integration configuration</p>
                <p>As you read the following discussion, you may find it useful to refer back to Figure 1.</p>
                <p>The configuration is structured into various sections, according to the needs of SI and of the
                    various resources that are being integrated.</p>
                <p>The si section (more precisely, those elements of SI configured via the XML namespace allocated the
                    si prefix in this document) configures the various aspects of SI itself. This includes establishing
                    the various channels that interlink the components, defining a few application-specific components
                    (such as the router and transformer), and putting in place a default polling schedule for those
                    parts of SI that need to poll.</p>
                <p>It is worth examining the router and transformer components here. I have mentioned that the JMS
                    services deal with a partitioned data space and that traffic is directed to an individual service
                    based on the actual data message being processed. SI allows for the definition of an
                    application-specific router to perform this type of task, in this case the method route of the
                    highLowRouter instance. Listing 7 shows the code for the router.</p>
                <pre>
package au.com.transentia.si

public class LookupRouter {

  public String route(String msg) {
    switch(msg) {
      case ~/(?i:[a-l].*)/: return 'ALOutboundChannel'
      case ~/(?i:[m-z].*)/: return 'MZOutboundChannel'
      default: return 'reject'
    }
  }
}
</pre>
                <p>Listing 7: The router class</p>
                <p>The router examines the incoming message data and determines the appropriate outbound path for the
                    message. Groovy&#8217;s wonderfully versatile switch statement, combined with the ability to do
                    case-independent pattern matching, makes for beautifully minimalistic code.</p>
                <p>The transformer is equally simple, as Listing 8 shows.</p>
                <pre>
package au.com.transentia.si

public class CsvTransformer {
  def homeBase

  public String transform(String csv) {
    def dest = csv.tokenize(',')[1]

    """<def :calculateShippingCost xmlns:def="http://DefaultNamespace">
         </def><def :arg0>$homeBase</def>
         <def :arg1>$dest</def>
         <def :arg2>1</def>
      """
  }
}
</pre>
                <p>Listing 8: The transformer class</p>
                <p>This code is presented with an input CSV-formatted record, extracts the relevant field, and passes an
                    XML-formatted string onwards.</p>
                <p>Recall that the WebService&#8217;s API is not custom-built for the purpose of this application; for
                    this use, arg2 (the nItems parameter) is always fixed at 1.</p>
                <p>The stream section of the configuration merely allocates a generic channel listener so that the
                    standard errorChannel is not silently ignored; this configuration will ensure that
                    errors/exceptions, etc., are logged.</p>
                <p>The ws section deals&#8211;unsurprisingly&#8211;with WebService integration. The section configures
                    an SI outbound gateway that is capable of receiving a request on a specified channel, invoking the
                    configured WebService and finally sending the result to the appropriate response channel. All this
                    is specified declaratively: the actual mechanism of dealing with the WebService (retrieving WSDL
                    documents, generating proxies and handling XML-based request/response messages) is completely hidden
                    away.</p>
                <p>The remaining configuration concerns SI&#8217;s JMS adapter and ActiveMQ integration.</p>
                <p>The siGateway has been discussed previously.</p>
                <p>By default, all SI&#8217;s JMS adapters reference a bean with the standard name of connectionFactory.
                    It is the responsibility of this bean to ‘vend&#8217; connections to the external JMS system. In
                    this case, a connection pool to a local Apache ActiveMQ server running at the URL &#8220;tcp://localhost:61616&#8243;
                    is being created. Since the external connections are pooled for efficiency, by specifying
                    destroyMethod=&#8217;stop&#8217; we ensure that they are simply inactivated after each (re)use and
                    are never actually discarded.</p>
                <p>Note: I found the actual syntax used to declare the connectionFactory a little tricky. I had to ask
                    for help on the excellent user@grails.codehaus.org mailing list to get it right! Thanks to the
                    generous souls who pointed me in the right direction.</p>
                <p>Following the definition of the the connectionFactory, we create two instances of ActiveMQ queues and
                    an instance of an ActiveMQ topic. It is these that carry the messages to/from the external JMS
                    resources.</p>
                <p>The jms section configures two JMS-specific outbound channel adapters and one inbound channel
                    adapter. As the names suggest, these are concerned with driving (or being driven by) the ActiveMQ
                    instances declared above. The configured message-driven-channel-adapter instance defines a component
                    that will be asynchronously &#8220;actively invoked&#8221; to handle an incoming message. It is
                    possible to configure a polling-oriented component, but this is generally less flexible, and may
                    waste CPU, and increase the latency in the system.</p>
                <p>As with the WebService gateway, everything is declarative.</p>
                <h1>Admiring the Finished Puzzle</h1>
                <p>SI has enabled a deceptively simple solution to a fairly complex problem. There are no messy tracts
                    of confusing mechanistic code; the system is essentially defined all in a single configuration; the
                    individual components are simple and (generally) reusable; and the groundwork for coping with change
                    set with very little effort.</p>
                <p>SI is a simple but powerful toolkit; the example application I have discussed here has really just
                    touched the surface of what is possible. SI provides much more, including facilities for secure
                    channels, inbound/outbound mail handling, event handling, RMI integration and much better XML
                    handling than I have touched upon here.</p>
                <p>Remember that these are still early days for SI: for example, there are no debuggers or GUI editors
                    as found in the big &#8220;name brand&#8221; systems integration tools. In time these tools may come
                    but for now remember that SI is orders of magnitude simpler, and the SI/Groovy/Grails triumvirate
                    makes the developer many times more productive than some other tools I have used.</p>
                <p>I hope that I have stimulated your interest in SI and shown that a Grails application need not be
                    limited to serving up &#8220;little web apps&#8221; but can actually service the needs of
                    larger-scale systems integration tasks.</p>
                <p>I hope that I have also been able to show that when the time comes to get out the scissors, Groovy is
                    more than equal to the task of &#8220;slicing and dicing&#8221; until the pieces of the systems
                    integration jigsaw puzzle fit nicely together.</p>
                <h1>Learn More</h1>
                <ul>
                    <li>Gregor Hohpe and Bobby Woolf, <em>Enterprise</em><em> Integration Patterns : Designing,
                        Building, and Deploying Messaging Solutions (ISBN 0321200683)</em>, also <a
                            href="http://www.enterpriseintegrationpatterns.com/">http://www.enterpriseintegrationpatterns.com/</a>
                    </li>
                    <li>Spring Integration Home, <a href="http://www.springsource.org/spring-integration">http://www.springsource.org/spring-integration</a>
                    </li>
                    <li>Apche ActiveMQ, <a href="http://activemq.apache.org/">http://activemq.apache.org</a></li>
                    <li>GroovyWS, <a href="http://docs.codehaus.org/display/GROOVY/GroovyWS">http://docs.codehaus.org/display/GROOVY/GroovyWS</a>.
                        The exemplar application uses the 0.5 snapshot jars from <a
                                href="http://snapshots.dist.codehaus.org/groovy/distributions/groovyws/">http://snapshots.dist.codehaus.org/groovy/distributions/groovyws/</a>
                    </li>
                </ul>
                <p><em>Bob Brown is the director and owner of Transentia Pty. Ltd.. Based in beautiful Brisbane,
                    Australia, Bob is a specialist in Enterprise Java and has found his niche identifying and applying
                    leading-edge technologies and techniques to customers problems.</em></p>
                <hr/>
                <p>Watch out for my other Groovymag articles&#8230;coming soon to a browser near you.</p>

            </div><!--/entry-content-->


            <p class="filed tags">Tags: Grails, Groovy, Programming, SOA, Tools</p>    <!--/filed-->

        </div><!-- .post -->
        <div class="post hentry">
            <h1 class="entry-title">About Bloody Time!</h1>
            <div class="entry-content">
                <p><a href="http://blogs.msdn.com/ie/archive/2010/01/05/microsoft-joins-w3c-svg-working-group.aspx">Microsoft
                    Joins W3C SVG Working Group</a>.</p>
                <p>Maybe it means something good is around the corner, maybe not. One can but hope&#8230;</p>

            </div><!--/entry-content-->


            <p class="filed tags">Tags: Tools</p>    <!--/filed-->

        </div><!-- .post -->
        <div class="post hentry">
            <h1 class="entry-title">Happy Birthday Transentia!</h1>
            <div class="entry-content">
                <p><img src="wp-content/uploads/2010/01/Happy10thBirthday1.png" alt="Happy10thBirthday"
                        title="Happy10thBirthday" width="678" height="454" />
                </p>
                <p>Transentia is <em>Ten years old</em> today.</p>
                <p>Transentia is a baby of the dot-com era. We started out wrangling Java and are coming into the second
                    decade having adopted Groovy as a technology platform.</p>
                <p>This is a good time to reflect on the origin of the name&#8230;</p>
                <p>It all started while I was a member of the &#8220;Business Development&#8221; team at DSTC. </p>
                <p>After a session wrestling with a group of research staff (collective noun: a <a
                        href="http://www.merriam-webster.com/dictionary/recalcitrant">recalcitrant</a>?) a colleague
                    (who shall remain <a href="http://en.wikipedia.org/wiki/Nameless_One_(Marvel_Comics)">nameless</a>)
                    stormed into my office and yelled &#8220;I don&#8217;t know what we are doing, but it sure as hell
                    isn&#8217;t technology transfer.&#8221; </p>
                <p>He came up with the phrase &#8220;Technology Transferention&#8221;, explaining: &#8220;It sounds good
                    and can impress people who don&#8217;t know any better, but it doesn&#8217;t actually mean a darned
                    thing. Exactly right for what we do.&#8221; That phrase got a fair bit of mileage :-)</p>
                <p>While casting around for a company name I recalled this event. </p>
                <p>I decided that &#8220;Transferention Technologies&#8221; was a bit too much of a mouthful and munged
                    it around a bit; thus the name <em>Transentia</em> was born.</p>
                <p>(The alternative was a play on another phrase the team used when confronted with an absurd situation:
                    &#8220;the sky is green, the trees are blue.&#8221; That got a <em>lot</em> of airplay too, but I
                    couldn&#8217;t quite work it into a good company name: &#8220;Green Sky Technologies&#8221; sounds a
                    bit too vomit-induc{ed/ing}.)</p>
                <p>Nowadays, there&#8217;s a &#8220;Land of Transentia&#8221; in some online game, a (Japanese?)
                    musician, and a cybersquatter is sitting on &#8216;transentia.com&#8217; (and can continue to sit,
                    as far as I am concerned. I deliberately chose an australian <a href="http://www.transentia.com.au">.com.au</a>
                    domain&#8230;we are a much more exclusive club :-))</p>

            </div><!--/entry-content-->


            <p class="filed tags">Tags: Retrospectives</p>    <!--/filed-->

        </div><!-- .post -->
        <div class="post hentry">
            <h1 class="entry-title">Font Squirrel</h1>
            <div class="entry-content">
                <p>Apparently: &#8220;<a href="http://www.fontsquirrel.com/">Free fonts have met their match</a>.&#8221;
                </p>
                <p>I found the site as I was reading the page describing the new <a
                        href="http://hacks.mozilla.org/2009/10/woff/">Web Open Font Format for Firefox 3.6</a>.</p>
                <p>Worth remembering. </p>

            </div><!--/entry-content-->


            <p class="filed tags">Tags: Tools</p>    <!--/filed-->

        </div><!-- .post -->
        <div class="post hentry">
            <h1 class="entry-title">Microsoft Calendar Printing Assistant</h1>
            <div class="entry-content">
                <p>My wife is always asking me to print calendar &#8216;blanks&#8217; for her.</p>
                <p>The <a href="http://office.microsoft.com/en-us/outlook/ha101687211033.aspx">Calendar Printing
                    Assistant for Outlook 2007</a> is a nice freebie from Microsoft to do just that (and more, of
                    course).</p>
                <p>There&#8217;s loads of styles to choose from and it can even print year calendars:</p>
                <p><img src="wp-content/uploads/2010/01/CPAOCapture.PNG" alt="CPAOCapture" title="CPAOCapture"
                        width="600" height="475" /></p>
                <p>This makes up for the strange oversight in Outlook proper.</p>
                <p>It&#8217;s really quite <a href="http://www.alphadictionary.com/goodword/word/grouse">grouse</a>!</p>

            </div><!--/entry-content-->


            <p class="filed tags">Tags: Tools</p>    <!--/filed-->

        </div><!-- .post -->
        <div class="post hentry">
            <h1 class="entry-title">Truth In Advertising!</h1>
            <div class="entry-content">
                <p>Well I never!</p>
                <p>This was broadcast on 31 Dec, 2009 at 21:52 on (Brisbane, Australia) Channel 7 Digital free-to-air
                    T.V.:</p>
                <p><img src="wp-content/uploads/2010/01/retraction.jpg" alt="retraction" title="retraction"
                        width="732" height="530" /></p>
                <p>I am tickled pink! It&#8217;s not often that one sees a piece of <a
                        href="http://www.quackwatch.com/">quack medicine</a> forced to identify itself as such.</p>
                <p>In case you can&#8217;t read it clearly, the last part says:</p>
                <blockquote><p>&#8230;failed to provide any evidence that the advertised Ease-A-Cold product can shorten
                    colds or reduce the duration of colds.</p></blockquote>
                <p>If only we could get the cosmetics companies as well&#8230;as <a
                        href="http://www.newscientist.com/article/mg19826545.400-comment-what-lies-beneath-the-makeup.html">this
                    article</a> in New Scientist says:</p>
                <blockquote><p>&#8230;cosmetics companies release very little in the way of trial data. In medical
                    practice, the gold standard for proof of persistent benefit to a patient is the double-blind
                    randomised controlled trial (RCT), published in a peer-reviewed journal. So why do we not see such a
                    well-established methodology used for cosmetics?</p>
                    <p>The industry faces a dilemma. If a rigorous trial of an anti-ageing cream showed no benefit, no
                        one would buy it. Yet if it really does produce structural changes and permanently reduces
                        wrinkles, the cream could be reclassified as a pharmaceutical agent &#8211; which would mean it
                        could no longer be sold to the public unless prescribed by a doctor.</p></blockquote>
                <p>As <a
                        href="http://www.newscientist.com/article/mg15020314.800-wrinkle-wars--the-big-guns-of-research-are-being-brought-to-bear-on-the-wrinkle-rosie-mestel-investigates-the-latest-claims-in-cosmetics.html?full=true&#038;print=true">this
                    article</a> rightly points out:</p>
                <blockquote><p>A businessman&#8217;s perspective might be `I can market this product today without a
                    trial, probably make more liberal claims about it, and get millions of dollars-worth of exposure
                    instead&#8217;.</p></blockquote>
                <p>I wonder if a retraction like the one above actually has <em>any affect</em> on profits. Or indeed,
                    sales?</p>
                <p>In a related observation, I was shopping for a new pillow in the local boxing-day sales, when I came
                    across a beauty: a natural-latex pillow infused with activated charcoal to provide a hygenic sleep
                    environment that can also absorb any harmful electromagnetic radiation that might be passing by.</p>
                <p>I paraphrase (I really should have taken a brochure, but I simply couldn&#8217;t: I didn&#8217;t want
                    to be responsible for contributing even such dross as it to the landfill), but you get the idea.</p>
                <p>Such fakery! <a href="http://en.wikipedia.org/wiki/The_Demon-Haunted_World">The Demon-Haunted
                    World</a> remains a scary, confusing place for too many, it seems.</p>

            </div><!--/entry-content-->


            <p class="filed tags">Tags: Rant</p>    <!--/filed-->

        </div><!-- .post -->
        <div class="post hentry">
            <h1 class="entry-title">JRobin</h1>
            <div class="entry-content">
                <p>Following on from the previous post about <a href="javamelody/">JavaMelody</a>&#8230;</p>
                <blockquote><p><a href="http://oldwww.jrobin.org/">JRobin</a> supports all standard operations on Round
                    Robin Database (RRD) files: CREATE, UPDATE, FETCH, LAST, DUMP, XPORT and GRAPH</p></blockquote>
                <p>.</p>
                <p>It mimics <a href="http://oss.oetiker.ch/rrdtool/">RRDtool</a>, which apparently:</p>
                <blockquote><p>is the OpenSource industry standard, high performance data logging and graphing system
                    for time series data. Use it to write your custom monitoring shell scripts or create whole
                    applications using its Perl, Python, Ruby, TCL or PHP bindings.</p></blockquote>
                <p>.</p>
                <p>JRobin is a Java re-write (not an RRDTool binding). It can do things like:</p>
                <p><img src="wp-content/uploads/2009/12/stress.png" alt="stress" title="stress" width="497"
                        height="356" /></p>
                <p>See the <a href="http://oldwww.jrobin.org/gallery.html">JRobin Gallery for more</a>.</p>
                <p>Wish I&#8217;d found out about this <a href="a-universe-of-appsand-pain/">a few years back</a>.</p>

            </div><!--/entry-content-->


            <p class="filed tags">Tags: Tools</p>    <!--/filed-->

        </div><!-- .post -->
        <div class="post hentry">
            <h1 class="entry-title">JavaMelody</h1>
            <div class="entry-content">
                <p>Looks like an interesting tool to keep in mind:</p>
                <blockquote><p>The goal of <a href="http://www.grails.org/plugin/grails-melody">JavaMelody</a> is to
                    monitor Java or Java EE applications servers in QA and production environments. &#8230; it is a tool
                    to measure and calculate statistics on real operation of an application depending on the usage of
                    the application by users.</p></blockquote>
                <p>There&#8217;s a <a href="http://www.grails.org/plugin/grails-melody">Grails plugin</a> as well, which
                    is icing on the cake.</p>

            </div><!--/entry-content-->


            <p class="filed tags">Tags: Grails, Programming, Tools</p>    <!--/filed-->

        </div><!-- .post -->
        <div class="pagination">
            <span class="next"><a href="DUMMY">Next &raquo;</a></span>
            <span class="previous"><a href="DUMMY">&laquo; Previous</a></span>
        </div>

    </div>


</div><!--#page-->
<script
        src="https://code.jquery.com/jquery-3.4.1.min.js"
        integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
        crossorigin="anonymous"></script>
<script src="js/site.js"></script>
</body>
</html>
